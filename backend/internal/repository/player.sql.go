// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: player.sql

package repository

import (
	"context"
)

const joinGroup = `-- name: JoinGroup :one
WITH 
player_check AS (
    SELECT 1 FROM GroupMembers gm
    WHERE gm.player_id = $4
    LIMIT 1
),

role_counts AS (
    SELECT 
        COUNT(CASE WHEN p.role = 'vanguard' THEN 1 END) as curr_vanguards,
        COUNT(CASE WHEN p.role = 'duelist' THEN 1 END) as curr_duelists,
        COUNT(CASE WHEN p.role = 'strategist' THEN 1 END) as curr_strategists
    FROM GroupMembers gm
    JOIN Players p ON p.id = gm.player_id
    WHERE gm.group_id = $1
),

valid_group AS (
    SELECT g.id
    FROM Groups g, role_counts rc
    WHERE g.id = $1
    AND g.gamemode = $5
    AND g.region = $6
    -- Platform check (only if platforms specified)
    AND (
        ARRAY_LENGTH(g.platforms, 1) IS NULL 
        OR ARRAY_LENGTH(g.platforms, 1) = 0 
        OR $7::TEXT = ANY(g.platforms)
    )
    -- Role queue check (only if enabled)
    AND (
        (g.vanguards + g.duelists + g.strategists = 0)
        OR
        (
            -- Can fill at least one role
            ($8 = 'vanguard' AND rc.curr_vanguards < g.vanguards)
            OR ($8 = 'duelist' AND rc.curr_duelists < g.duelists)
            OR ($8 = 'strategist' AND rc.curr_strategists < g.strategists)
        )
    )
    -- Rank check
    AND EXISTS (
        SELECT 1
        FROM Players p2
        WHERE p2.id IN (SELECT player_id FROM GroupMembers WHERE group_id = g.id)
        AND ABS(p2.rank - $9) <= 10
    )
    -- If group is not open, check if passcode is correct
    AND (
        g.open 
        OR (NOT g.open AND g.passcode = $3)
    )
    LIMIT 1
),

player_creation AS (
    INSERT INTO Players (
        name,
        platform,
        role,
        rank,
        characters,
        voice_chat,
        mic,
        vanguards,
        duelists,
        strategists
    )
    SELECT 
        $10,
        $7::TEXT,
        $8,
        $9,
        $11,
        $12,
        $13,
        $14,
        $15,
        $16
    WHERE 
        NOT EXISTS (SELECT 1 FROM player_check)
        AND EXISTS (SELECT 1 FROM valid_group)
        AND NOT EXISTS (SELECT 1 FROM Players WHERE id = $4)
    RETURNING id
),

group_member_creation AS (
    INSERT INTO GroupMembers (
        group_id,
        player_id,
        leader
    )
    SELECT 
        $1,
        COALESCE(
            (SELECT id FROM player_creation),
            $4
        ),
        false
    WHERE EXISTS (SELECT 1 FROM valid_group)
    AND NOT EXISTS (SELECT 1 FROM player_check)
    RETURNING player_id
)

SELECT 
    CASE
        WHEN EXISTS (SELECT 1 FROM player_check) THEN '400a'
        WHEN NOT EXISTS (SELECT 1 FROM Groups g WHERE g.id = $1) THEN '404'
        WHEN EXISTS (SELECT 1 FROM group_member_creation) THEN '200'
        WHEN EXISTS (
            SELECT 1 FROM Groups g 
            WHERE g.id = $2 
            AND NOT g.open 
            AND g.passcode != $3
        ) THEN '403'
        WHEN NOT EXISTS (SELECT 1 FROM valid_group) THEN '400e'
        ELSE '500'
    END as status,
    COALESCE(
        (SELECT player_id FROM group_member_creation),
        0
    )::integer as player_id
`

type JoinGroupParams struct {
	GroupID     string      `json:"group_id"`
	ID          string      `json:"id"`
	Passcode    string      `json:"passcode"`
	PlayerID    int32       `json:"player_id"`
	Gamemode    string      `json:"gamemode"`
	Region      string      `json:"region"`
	Platform    string      `json:"platform"`
	Role        interface{} `json:"role"`
	RankVal     int32       `json:"rank_val"`
	Name        string      `json:"name"`
	Characters  []string    `json:"characters"`
	VoiceChat   bool        `json:"voice_chat"`
	Mic         bool        `json:"mic"`
	Vanguards   int32       `json:"vanguards"`
	Duelists    int32       `json:"duelists"`
	Strategists int32       `json:"strategists"`
}

type JoinGroupRow struct {
	Status   string `json:"status"`
	PlayerID int32  `json:"player_id"`
}

// First check if player is already in a group
// Get current role counts for the group
// Check all requirements in a single query
// Insert player if they don't exist and group is valid
// Create group membership if everything valid
// Return status code
func (q *Queries) JoinGroup(ctx context.Context, arg JoinGroupParams) (JoinGroupRow, error) {
	row := q.db.QueryRow(ctx, joinGroup,
		arg.GroupID,
		arg.ID,
		arg.Passcode,
		arg.PlayerID,
		arg.Gamemode,
		arg.Region,
		arg.Platform,
		arg.Role,
		arg.RankVal,
		arg.Name,
		arg.Characters,
		arg.VoiceChat,
		arg.Mic,
		arg.Vanguards,
		arg.Duelists,
		arg.Strategists,
	)
	var i JoinGroupRow
	err := row.Scan(&i.Status, &i.PlayerID)
	return i, err
}
