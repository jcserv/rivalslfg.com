// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: player.sql

package repository

import (
	"context"
)

const joinGroup = `-- name: JoinGroup :one
WITH 
player_check AS (
    SELECT 1 FROM GroupMembers gm
    WHERE gm.player_id = $3
    LIMIT 1
),

group_members_base AS (
    SELECT 
        gm.group_id,
        p.id as player_id,
        p.name,
        gm.leader,
        p.platform,
        LOWER(p.role) as role,
        p.rank as rank_val,
        p.characters,
        p.voice_chat,
        p.mic
    FROM GroupMembers gm
    JOIN Players p ON p.id = gm.player_id
),

group_details AS (
    SELECT 
        group_id,
        COUNT(CASE WHEN role = 'vanguard' THEN 1 END) as curr_vanguards,
        COUNT(CASE WHEN role = 'duelist' THEN 1 END) as curr_duelists,
        COUNT(CASE WHEN role = 'strategist' THEN 1 END) as curr_strategists,
        MIN(rank_val) as min_rank,
        MAX(rank_val) as max_rank
    FROM group_members_base
    GROUP BY group_id
),

valid_group AS (
    SELECT g.id
    FROM Groups g, group_details gd
    WHERE g.id = $1
    AND g.gamemode = $4
    AND g.region = $5
    -- Platform check
    AND g.platform = $6
    -- Role queue check (only if enabled)
    AND (
        (g.vanguards + g.duelists + g.strategists = 0)
        OR
        (
            -- Can fill at least one role
            ($7 = 'vanguard' AND gd.curr_vanguards < g.vanguards)
            OR ($7 = 'duelist' AND gd.curr_duelists < g.duelists)
            OR ($7 = 'strategist' AND gd.curr_strategists < g.strategists)
        )
    )
    -- Rank check
    AND (
        -- Allow Bronze-Gold players to group with each other
        $8 BETWEEN 0 AND 22 AND gd.min_rank BETWEEN 0 AND 22
        OR (
            ABS(gd.min_rank - $8) <= 10
            AND ABS(gd.max_rank - $8) <= 10
        )
    )
    -- If group is not open, check if passcode is correct
    AND (
        g.open 
        OR (NOT g.open AND g.passcode = $2)
    )
    LIMIT 1
),

player_creation AS (
    INSERT INTO Players (
        name,
        platform,
        role,
        rank,
        characters,
        voice_chat,
        mic,
        vanguards,
        duelists,
        strategists
    )
    SELECT 
        $9,
        $6::TEXT,
        $7,
        $8,
        $10,
        $11,
        $12,
        $13,
        $14,
        $15
    WHERE 
        NOT EXISTS (SELECT 1 FROM player_check)
        AND EXISTS (SELECT 1 FROM valid_group)
        AND NOT EXISTS (SELECT 1 FROM Players WHERE id = $3)
    RETURNING id
),

group_member_creation AS (
    INSERT INTO GroupMembers (
        group_id,
        player_id,
        leader
    )
    SELECT 
        $1,
        COALESCE(
            (SELECT id FROM player_creation),
            $3
        ),
        false
    WHERE EXISTS (SELECT 1 FROM valid_group)
    AND NOT EXISTS (SELECT 1 FROM player_check)
    RETURNING player_id
)

SELECT 
    CASE
        WHEN EXISTS (SELECT 1 FROM player_check) THEN '400a'
        WHEN NOT EXISTS (SELECT 1 FROM Groups g WHERE g.id = $1) THEN '404'
        WHEN EXISTS (SELECT 1 FROM group_member_creation) THEN '200'
        WHEN EXISTS (
            SELECT 1 FROM Groups g 
            WHERE g.id = $1
            AND NOT g.open 
            AND g.passcode != $2
        ) THEN '403'
        WHEN NOT EXISTS (SELECT 1 FROM valid_group) THEN '400e'
        ELSE '500'
    END as status,
    COALESCE(
        (SELECT player_id FROM group_member_creation),
        0
    )::integer as player_id
`

type JoinGroupParams struct {
	GroupID     string      `json:"group_id"`
	Passcode    string      `json:"passcode"`
	PlayerID    int32       `json:"player_id"`
	Gamemode    string      `json:"gamemode"`
	Region      string      `json:"region"`
	Platform    string      `json:"platform"`
	Role        interface{} `json:"role"`
	RankVal     interface{} `json:"rank_val"`
	Name        string      `json:"name"`
	Characters  []string    `json:"characters"`
	VoiceChat   bool        `json:"voice_chat"`
	Mic         bool        `json:"mic"`
	Vanguards   int32       `json:"vanguards"`
	Duelists    int32       `json:"duelists"`
	Strategists int32       `json:"strategists"`
}

type JoinGroupRow struct {
	Status   string `json:"status"`
	PlayerID int32  `json:"player_id"`
}

// First check if player is already in a group
// Check all requirements in a single query
// Insert player if they don't exist and group is valid
// Create group membership if everything valid
// Return status code
func (q *Queries) JoinGroup(ctx context.Context, arg JoinGroupParams) (JoinGroupRow, error) {
	row := q.db.QueryRow(ctx, joinGroup,
		arg.GroupID,
		arg.Passcode,
		arg.PlayerID,
		arg.Gamemode,
		arg.Region,
		arg.Platform,
		arg.Role,
		arg.RankVal,
		arg.Name,
		arg.Characters,
		arg.VoiceChat,
		arg.Mic,
		arg.Vanguards,
		arg.Duelists,
		arg.Strategists,
	)
	var i JoinGroupRow
	err := row.Scan(&i.Status, &i.PlayerID)
	return i, err
}

const removePlayer = `-- name: RemovePlayer :one
WITH group_check AS (
    -- Check if group exists and player is in it
    SELECT group_id, player_id, leader
    FROM GroupMembers gm
    WHERE gm.group_id = $1
    AND gm.player_id = $2
    LIMIT 1
),
group_size AS (
    -- Get total members in group
    SELECT COUNT(*) as member_count
    FROM GroupMembers
    WHERE group_id = $1
),
is_last_member AS (
    -- Check if this is the last member
    SELECT (SELECT member_count FROM group_size) = 1 as is_last
),
next_leader AS (
    -- Find next leader if current leader is leaving and not last member
    SELECT gm.player_id
    FROM GroupMembers gm
    JOIN group_check gc ON gm.group_id = gc.group_id
    WHERE gm.player_id != $2
    AND NOT EXISTS (SELECT 1 FROM is_last_member WHERE is_last)
    ORDER BY gm.leader DESC, RANDOM()
    LIMIT 1
),
promote_leader AS (
    -- Promote next leader if current leader is leaving and not last member
    UPDATE Groups
    SET owner = (
        SELECT name
        FROM Players
        WHERE id = (SELECT player_id FROM next_leader)
    )
    WHERE id = $1
    AND EXISTS (
        SELECT 1 FROM group_check
        WHERE leader = true
    )
    AND EXISTS (SELECT 1 FROM next_leader)
    RETURNING id
),
promote_member AS (
    -- Update group membership for new leader if not last member
    UPDATE GroupMembers
    SET leader = true
    WHERE group_id = $1
    AND player_id = (SELECT player_id FROM next_leader)
    AND EXISTS (
        SELECT 1 FROM group_check
        WHERE leader = true
    )
    RETURNING player_id
),
remove_member AS (
    -- Remove the player from the group
    DELETE FROM GroupMembers
    WHERE group_id = $1
    AND player_id = $2
    AND EXISTS (SELECT 1 FROM group_check)
    RETURNING group_id
),
delete_empty_group AS (
    -- Delete group if this was the last member
    DELETE FROM Groups g
    WHERE g.id = $1
    AND EXISTS (SELECT 1 FROM is_last_member WHERE is_last)
    RETURNING id
)
SELECT 
    CASE
        WHEN NOT EXISTS (SELECT 1 FROM group_check) THEN
            '404'::TEXT  -- Group not found or player not in group
        WHEN EXISTS (SELECT 1 FROM is_last_member WHERE is_last) THEN
            '204'::TEXT  -- Last member left, group will be deleted
        ELSE
            '200'::TEXT  -- Successfully removed player
    END as status,
    COALESCE(
        (SELECT player_id FROM next_leader)::INTEGER,
        0
    ) as new_leader_id
`

type RemovePlayerParams struct {
	GroupID  string `json:"group_id"`
	PlayerID int32  `json:"player_id"`
}

type RemovePlayerRow struct {
	Status      string      `json:"status"`
	NewLeaderID interface{} `json:"new_leader_id"`
}

func (q *Queries) RemovePlayer(ctx context.Context, arg RemovePlayerParams) (RemovePlayerRow, error) {
	row := q.db.QueryRow(ctx, removePlayer, arg.GroupID, arg.PlayerID)
	var i RemovePlayerRow
	err := row.Scan(&i.Status, &i.NewLeaderID)
	return i, err
}
